# 開発思想・設計方針

## 1. 開発思想

### コードの品質
- 「正しく動く」とは、仕様を正しく把握し、実装中にも仕様の漏れや気づきを反映すること。
- 「正しく動作し続ける」ためにはテストが重要。テストがあることで拡張やリファクタリングがしやすくなる。
- パフォーマンスや監視も品質の一部。要件変更に強いことがビジネス価値につながる。
- 低品質なコードはバグが多く、開発効率も悪化する。
- 既存の共通部品を把握し、無駄な再実装を避ける。

### 抽象化レイヤー
- 大きな問題は小さな問題に分割し、関数・クラス・パッケージなどで整理する。
- 関心の分離、高凝集・疎結合を意識する。
- クラス分割の基準は「読みやすさ」「モジュール性」「再利用性」「テスタビリティ」。
- コードレビュー前に自分で批判的に読む。3ヶ月後や他人が読んでも理解できるかを意識する。
- レイヤーの厚さは一律に決められないが、通常は薄い方が良い。

### コードでの契約
- 設計や使い方が保守・改良で壊されないようにするには、型やテストで保証する。
- 適切な名前付け、型の活用、ドキュメントの整備で誤用を防ぐ。
- コードを読むコストは高いので、使い方が分かりやすいAPI設計を心がける。

### エラー
- エラーは早く・目立つ形で失敗させる。エラー箇所に近い場所で通知する。
- 明示的なエラー通知（例：Result型や検査例外）を基本とし、呼び出し元が認識できるようにする。

### コードを読みやすくする
- 名前は分かりやすく、英語に厳密すぎなくても良いが、意味が伝わることを重視。
- dataやinformationなど曖昧な単語は避け、具体的な形容詞を使う。
- get/setの使い分けや、短すぎる名前・長すぎる名前のバランスに注意。
- コードは小さな関数に分割し、public関数のトップレベルで処理の流れが分かるようにする。

### 想定外の事態をなくす
- マジックバリューを返り値に使わない。nullやダミー値の扱いに注意。
- 副作用のある関数は名前で明示する。
- 列挙型のデフォルトケースや想定外の値には例外を投げて早く失敗させる。

### 誤用しにくいコードを書く
- すべてを不変にすることを検討する（コピーオンライトパターンなど）。
- 汎用的なデータ型（例：[number, number]）は避け、意味が分かる型やブランド型を使う。
- 変数名や型に単位を明示する（例：timeoutMsなど）。

### コードをモジュール化する
- ハードコーディングされた依存関係（DBやセッション層への直接アクセス）は避ける。
- 継承の問題点（不要な関数の公開、親の変更による子の破壊、重複コード）を意識し、コンポジションを活用する。
- クラスは自分自身に関心を持つべき。他のクラスの詳細を知りすぎないようにする。

### コードを再利用・汎用化しやすくする
- 安直な共通化や早まった最適化は逆効果になることがある。
- 関数の引数設計は、オブジェクト渡しと値渡しのトレードオフを考える。
- 引数の変更やリファクタリング時の影響範囲に注意。

### ユニットテストの原則と実践
- テストケースは「アレンジ（準備）」「アクト（実行）」「アサーション（検証）」で構成する。
- モック・スタブ・フェイクの使い分けを理解する。
- モック派（相互作用重視）と古典派（結果重視）の違いを意識する。
- テストケースは目的ごとに分け、不要に1つにまとめない。
- public関数のテストを重視し、private関数のテストは詳細に囚われすぎない。
- テストが書きづらくなったらクラスの責務が大きすぎないか疑う。レイヤー分割でクラスを薄く保つ。

## 2. 設計方針

### オブジェクト指向プログラミングの原則
- **SOLID原則**
  - S: 単一責任の原則（1つのクラス/モジュールは1つの責任のみ持つ）
  - O: オープン/クローズド原則（拡張に開き、修正に閉じる）
  - L: リスコフの置換原則（派生クラスは親クラスと置き換え可能であるべき）
  - I: インターフェース分離原則（クライアントごとに必要なインターフェースのみ提供）
  - D: 依存性逆転の原則（抽象に依存し、具体に依存しない）
- **YAGNI**（You Aren't Gonna Need It）
  - 「今必要でない機能は作らない」ことを徹底し、過剰な設計・実装を避ける。
- **DRY**（Don't Repeat Yourself）
  - 同じロジックや知識を複数箇所に持たない。共通化・再利用を意識する。
- **早すぎる共通化は避ける**
  - まだ十分にパターンが見えていない段階での共通化は、かえって保守性を下げるため注意する。

### その他の設計原則（参考記事要約）
- 「設計はシンプルに」「複雑さは分割して管理」「変更に強い設計を意識」
- 「依存関係は最小限に」「疎結合・高凝集を目指す」
- 「実装よりもインターフェースを重視」「テストしやすい設計」
- 「現実世界のモデルを意識しすぎず、ソフトウェアとしての最適な構造を考える」
- 「設計の意図や判断理由はドキュメント（ADR等）で明示する」

## 3. 設計レビューの運用
- 設計上重要な決定はADRとして記載し、そのADRを含むPull RequestがApproveされることで設計レビューを承認とする。
- モデルや設計の変更時も同様にADRの承認プロセスに従う。

## 4. DDD・TDDの適用範囲
- DDD（ドメイン駆動開発）はプロジェクト全体に適用。ただし、DDDを適用することで可読性や保守性が落ちる場合は、都度相談して進める。
- TDD（テスト駆動開発）は全機能に適用。ただし、難しい場面では都度相談する。

### ドメイン駆動開発（DDD）
- ソフトウェアの設計・実装を「業務（ドメイン）」の知識やルールに基づいて進める手法。
- ドメイン（業務領域）の専門家と開発者が共通言語（ユビキタス言語）で議論し、モデルを作る。
- 複雑な業務ロジックを整理し、保守性・拡張性の高いシステムを目指す。
- コード構造も「ドメインモデル」を中心に据え、アプリケーション層・インフラ層などに分離する。

### テスト駆動開発（TDD）
- まず「テスト」を書き、そのテストをパスする最小限の実装を行う開発手法。
- 「Red（失敗するテストを書く）→Green（テストが通る実装）→Refactor（リファクタリング）」のサイクルを繰り返す。
- バグの早期発見・仕様の明確化・リファクタリングのしやすさがメリット。

---

ご要望・参考記事の内容を反映しています。追加や修正があればご指示ください。
